---
layout: post
title:  "도메인 주도 설계 15 - 디스틸레이션"
date:   2019-06-20
desc:  "도메인 주도 설계 15 - 디스틸레이션"
keywords: "도메인 주도 설계, DDD, Domain, Domain Driven Design, Distillation, 디스틸레이션"
categories: [Programming]
tags: [DDD, Domain, Domain Driven Design]
icon: icon-html
---

Layered Architecture는 기술적 관심사로부터 도메인 개념을 분리한다. 도메인 주도 설계의 전제 조건은 도메인 영역 자체를 다루는 도메인 계층을 격리시키는 것이다. 하지만 **규모가 큰 시스템에서는 격리된 도메인 계층 그 자체도 관리가 되지 않을 정도로 복잡해질 수도 있다.**

우리는 개발을 진행하면서 도메인을 좀 더 깊이 있게 이해하고, 지식 탐구 및 심층 연구, 리팩터링 과정을 거쳐 도메인 지식의 정수를 추출한 모델을 형상화하여 코드에 반영하게 된다. **더 나아가서 도메인 계층에 있는 복잡한 도메인 모델의 여러 요소들을 분리하여 도메인 본질을 좀 더 값지고 유용한 형태로 뽑아내는 과정인 디스틸레이션(Distillation)이 있다.** 이 과정을 거치면 Generic Subdomain(일반 하위 도메인)과 Coherent Mechanism(응집력 있는 매커니즘)가 나타나는데, 이는 우리 도메인 핵심 영역인 Core Domain을 추출하기 위한 과정인 것이다.

![00.png](/static/assets/img/blog/programming/2019-06-20-domain_driven_design_15/00.png)

<br>

## Core Domain (핵심 도메인)

규모가 큰 시스템을 설계할 때는 시스템에 기여하는 구성요소가 매우 많은데, 도메인 계층이 너무 복잡한 나머지 도메인의 본질적인 측면이 가려질 때가 있다.

> 이해하기 힘든 시스템은 변경하기도 어렵고 변경의 파급 효과도 예측하기 어렵다.

> 개발을 진행하다보면, 각 개발자들은 각자 자신이 맡은 모듈에 대해서만 전문성을 갖추게 되는데 이는 개발자들끼리 지식 전달이 줄어들게 된다. 시스템은 매끄럽게 통합되기 힘들어지고, 업무 할당의 유연성도 떨어지게 된다. 코드의 중복도 일어나게 되고 시스템은 더욱 복잡해진다.

도메인 주도 설계, 개발을 하면서 모델을 정제해나가게 되는데, 모든 부분이 동일한 시점에 정제되지는 않는다. 따라서 각 모델, 설계에 우선순위를 매겨야 되는데, **도메인 모델을 가치있게 하려면 모델의 핵심적인 측면을 다루기 수월하게 하고 이를 충분히 활용할 수 있어야 한다.**

> 가끔 개발자들은 애플리케이션의 핵심부는 관심없고, 기술적인 내용에 관심이 있어 인프라스트럭처 계층이나 도메인 지식이 없어도 이해할 수 있는 일반적인 도메인 문제만 다루려고 할 때가 있다. 숙련된 개발자가 애플리케이션의 보조적인 기능이나 기술을 다루는 영역을 맡고, 초보 개발자가 핵심 모델을 다루는 경우도 있다. 소프트웨어의 핵심 부분의 설계 및 구현 품질이 낮다면 기술적인 인프라스트럭처나 보조기능이 얼마나 멋지든 사용자에게는 결코 매력적으로 다가오지 않는다.

**애플리케이션의 목적에 부합되고 중심적인 모델은 Core Domain(핵심 도메인)을 구성하는데, 이 영역이야말로 시스템에서 가장 큰 가치가 있는 곳이다.**

**모델을 요약하고 Core Domain을 찾아 그것을 지원하는 보조적인 역할을 맡은 다수의 모델과 코드로부터 구별할 수 있는 수단을 가져야 한다.** 그리고 이 영역에 가장 재능 있는 인력을 할당해야 한다. **시스템의 비전을 수행하기에 충분한 심층 모델을 찾아 유연한 설계로 이어지도록 Core Domain에 노력을 쏟아야 한다.**

도메인 정수를 추출하여 Core Domain으로 분리하는 것은 쉽지 않지만 의사 결정은 쉬워진다. **Core Domain에 역량을 쏟는 동시에 설계의 나머지 부분들은 실용적인 수준으로 일반화해서 유지해야 한다.**

> 어느 특정 영역이 경쟁사로부터 비밀스럽게 유지해야 한다면 그것이 바로 Core Domain이다.

<br>

### Core 선택

Core Domain은 애플리케이션의 성격마다 다를 수 있다. 어느 애플리케이션에는 Core Domain인 것이 다른 애플리케이션에서는 보조 컴포넌트의 역할일 수도 있다.

**애플리케이션의 Core Domain을 식별하고 정의하는 것은 도메인에 대한 통찰력과 경험이 깊어질 때 가능한 것이다. 반복적인 개발 주기 및 리팩터링을 통해 Core Domain을 파악하고 이를 구별할 수 있도록 하라.**

<br>

## Generic Subdomain (일반 하위 도메인)

모델의 일부는 비즈니스적으로 가치가 있는 전문 지식을 담고 있는 핵심 영역이 아님에도 불구하고 도메인 계층에 복잡성을 더하곤 한다. 이런 요소들은 Core Domain을 식별하고 이해하는 일을 어렵게 만들 수 있다.

> 이런 모델들은 보통 일반적인 기능, 예를 들면 환율 계산이나 위치에 따른 시간대 변환과 같은 것을 다루는 모델인 경우가 많다. 핵심 모델은 아니지만, 그럼에도 애플리케이션이 동작하고 핵심 모델을 완전히 표현하는 데 있어서 필요하다.

**일반적인 모델 요소가 매우 중요한 것으로 여겨지더라도 전체 도메인 모델은 시스템에서 가장 가치가 있는 특별한 측면, Core Domain을 두드러지게 하고 여기에 가능한 많은 노력과 비용이 실리게끔 구조화해야 한다.**

**비즈니스적 핵심 영역인 Core Domain이 아닌 일반적인 기능을 담는 응집력 있는 하위 도메인을 식별하라.** 이러한 하위 도메인에서 모델 요소를 추출해 별도 Module에 배치하라.

> 하위 도메인이 분리되고 나면 남겨진 Core Domain이 두드러지게 되고, 기타 도메인 모델에 의한 복잡성이 띄지 않을 뿐만 아니라 다루기가 한결 수월해져 충분히 활용할 수 있게 된다.

이러한 하위 도메인, **Generic Subdomain**에는 Core Domain보다 낮은 우선순위를 부여하고 그 일에 핵심 개발자를 배치하지 않도록 한다. 

> 일반적인 기능을 다루는 Generic Subdomain에 대해서는 외부 라이브러리나 다른 하위 시스템을 재활용할 수도 있다.

> 일반적인 기능, 일반화라는 것이 재사용 가능하다는 말이 아니다. 재사용에 신경을 써서 Core Domain에 노력을 기울일 수도 있는 시간과 비용을 허비하지 마라. 디스틸레이션의 기본 동기는 Core Domain에 가능한 많은 노력을 쏟게 하고, 보조적인 성격인 Generic Subdomain에는 필요한 만큼 투자하자는 것이다. Generic Subdomain은 Core Domain의 요구사항에 따라가야 한다. 당장 업무에 필요한 부분에 대해서만 모델링하고 구현하라.

