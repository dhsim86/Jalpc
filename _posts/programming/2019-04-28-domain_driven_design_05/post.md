---
layout: post
title:  "도메인 주도 설계 05 - 소프트웨어에서 표현되는 모델"
date:   2019-04-28
desc:  "도메인 주도 설계 05 - 소프트웨어에서 표현되는 모델"
keywords: "DDD, Domain, Domain Driven Design, 연관관계, associations"
categories: [Programming]
tags: [DDD, Domain, Domain Driven Design]
icon: icon-html
---

Model Driven Design의 효과를 놓치지 않으면서 구현과 조화를 이루려면 기본적인 사항을 재구성할 필요가 있다. **모델과 구현은 상세 수준에서 연결되어야 한다.**

도메인 개념을 담은 객체를 정의하는 일은 겉으로는 매우 쉬워보이지만 의미 상의 미묘한 차이로 발생할 수 있는 중대한 문제가 잠재되어 있다. **각 모델 요소의 의미를 명확하게 하고, 특정 종류의 객체를 도출하기 위해 설계에 부합하는 일정한 구분법이 있다.**

* 어떤 객체가 연속성과 식별성을 지니고 있는가? -> Entity
* 다른 무언가의 상태를 기술하는 속성에 불과한가? -> Value Object
* 상태보다는 행동이나 연산으로 명확히 표현되는 것 -> Service
  * 상태를 주고받지는 않는 활동을 모델링하는 경우
  
이런 기본 요소들은 관례적인 것으로, 그 개념을 따르는 모델링과 설계 경향에 대해서 예전부터 책이나 문헌으로 존재하였다. 그러한 개념에 맞게 더 규모가 큰 모델과 설계 문제를 다룰 때 개발자들이 도메인 주도 설계의 우선순위에 부합하는 세부 구성요소를 만드는데 도움이 될 수 있다.

<br>

## 연관관계

모델링과 실제 구현 간의 상호작용은 여러 객체 간의 연관관계에서 특히 까다롭다.

서로 다른 모델 객체끼리는 연관관계가 있다. 어느 두 사물들끼리의 연관관계를 나타내는 것은 두 사물에 관계된 것이다. 그러한 모델은 개발자가 실제 사물끼리의 관계를 추상화한 것이기도 하다.

일대다(one-to-many) 연관관계는 어느 인스턴스 변수에 필드로서 컬렉션을 두는 것으로 구현할 수 있다. 반드시 그렇게 되는 것은 아니며, 컬렉션이 없이 접근자 메서드에서 직접 데이터베이스를 조회하여 적절한 레코드를 찾은 다음 해당 레코드를 토대로 객체를 인스턴스화할 수도 있다. **어떤 형태로 구현하든 그러한 행위는 모델 내의 연관관계와 일치해야 한다.**

현실세계에는 수많은 다대다(many-to-many) 연관관계가 있는데, 상당수가 양방향 연관관계로 나타난다. 초기 도메인 모델링의 결과인 모델도 그와 같은 경향을 보인다. 이러한 일반적인 형태의 연관관계는 구현과 유지보수를 복잡하게 만든다.

연관관계를 좀더 쉽게 다루는 방법으로 아래의 세 가지가 있다.

1. 탐색 방향을 부여한다.
2. 한정자(qualifier)를 추가하여 사실상 다중성(multiplicity)를 줄인다.
3. 중요하지 않은 연관관계를 제거한다.

**가능한 한 관계를 제약하는 것이 중요하다.** 양방향 연관관계는 두 객체가 모두 있어야만 이해할 수 있다. 애플리케이션의 요구사항에 두 방향을 모두 탐색해야 한다는 요건이 없을 경우에는, 어느 한 방향으로만 탐색 방향을 추가하면 상호의존성이 줄어들고 설계가 단순해진다.

![00.png](/static/assets/img/blog/programming/2019-04-28-domain_driven_design_05/00.png)

국가와 역대 대통령에 대한 관계를 표현할 수 있는데, 이는 일대다 관계로 연관관계를 단순화시킬 수 있다. 대통령 이름으로 '이 대통령이 있던 나라가 어디입니까?' 라고 물어보지는 않는다. 위와 같이 단방향으로 탐색 방향을 제한함으로써 **설계가 단순해지고 도메인에 통찰력(연관관계에서 어느 특정 방향이 다른 것에 비해 더 의미있고 중요하다는 점)을 반영하게 된다.** 

> 어떤 탐색 방향은 도메인의 본연적인 특성을 드러낸다.

도메인을 깊이있게 이해하다보면 자주 **한정적인** 관계에 이른다. 대통령은 특정 시점에 한 명의 대통령만이 있다. 따라서 이러한 중요한 도메인 규칙을 명시적으로 모델에 포함시킨다면 다음과 같다.

![01.png](/static/assets/img/blog/programming/2019-04-28-domain_driven_design_05/01.png)

위와 같이 일대다와 같은 다중성을 일대일 관계로 제약하여 줄일 수 있다.

> 제약이 더해진 연관관계는 더 많은 도메인 지식과 실제적인 설계를 전해준다.

위와 같은 방법들로 연관관계를 제약하면 훨씬 더 구현이 용이해진다. **도메인의 특성이 드러나게끔 일관되게 제약하면 연관관계의 의사전달력이 더욱 풍부해지고 구현이 단순해진다.** 복잡한 다대다 관계를 구현하기 쉬운 일대다 관계로 바꿀 수 있으며, 한정자를 통해 다중성을 줄일 수 있다.

> 물론 양방향 연관관계가 도메인에 있어서 의미가 있고 애플리케이션의 요구사항에도 부합한다면 유지해야 한다.

중요한 의미를 담고 있지 않는 연관관계라면 완전히 제거하는 것이 좋다.

> 제약조건은 모델과 구현에 포함되어 있어야 한다. 그와 같은 제약조건은 모델을 더 정확하게 하고, 구현을 더욱 쉽게 유지보수할 수 있도록 해준다.

<br>

## Entity (엔티티)

수많은 객체는 본질적으로 해당 객체의 속성이 아닌 **연속성과 식별성이 이어지느냐를 기준으로 정의된다.**

많은 것들이 속성이 아닌 식별성에 의해 정의될 수 있다. '사람'을 나타내는 객체는 여러 시스템에서 그 객체의 형태가 각기 다를 수 있지만, 동일한 사람인지 아니면 다른 사람인지 파악알 필요가 있다. 이러한 **개념적 식별성은 객체와 해당 객체의 저장 형태, 구현 사이에서 일치해야 한다.**

객체 모델링을 할 때 속성에 집중하곤 하는데, **Entity의 근본적인 개념은 객체의 생명주기 내내 이어지는 추상적인 연속성이며 그러한 추상적인 연속성은 여러 형태를 거쳐 전달된다는 것이다.**

이러한 객체는 객체의 속성을 자신의 주된 정의로 삼지 않는다. 오랜 시간에 걸쳐 작용하는 식별성의 이어짐이 나타나며, 그 형태는 종종 다르게 나타나기도 한다. 

**어떤 객체를 일차적으로 해당 객체의 식별성으로 정의할 경우 그 객체를 Entity(엔티티)라고 한다.** Entity는 자신의 생명주기 동안 형태와 내용은 바뀌더라도 연속성은 유지해야 한다. 이런 객체를 추적하기 위해서는 식별성이 정의되어 있어야 한다. **Entity의 클래스 정의와 책임, 속성, 연관관계는 Entity의 특정 속성보다는 정체성에 초첨을 맞추어야 한다.**

> Entity는 생명 주기 내내 이어지는 연속성과 애플리케이션 사용자에게 중요한 속성과는 다른 독립적인 특징을 가진 것이다.

> 모델 내의 모든 객체가 의미있는 식별성을 지닌 Entity인 것은 아니다.

**한 객체가 속성보다는 식별성으로 구분될 경우 모델 내에서 이를 해당 객체의 주된 정의로 삼아야 한다.** 클래스 정의를 단순히 하고 생명주기의 연속성과 식별성에 집중해야 한다.

> 식별성을 주된 정의로 삼고, 집중하기 위해 객체의 형태나 이력에는 상관없이 각 객체를 구별하기 위한 수단이 있어야 한다. 이러한 식별 수단의 구현 방법은 여러가지가 있겠지만 모델에서 이 식별성을 구분하는 방법과 일치해야 한다.

> 식별성은 원래 세상에 존재하는 것이 아닌, 필요에 의해 보충된 의미이다. 현실세계의 같은 사물을 표현한 것일지라도 도메인 모델에서 Entity로 표현되거나 표현되지 않을 수 있다.

<br>

### Entity 모델링

객체를 모델링할 때 속성에 관해 생각하는 것은 자연스러운 일이며, 객체의 행위에 관해 생각해보다는 것은 아주 중요하다. 

**Entity의 가장 기본적인 책임은 객체의 행위가 명확하고 예측 가능하도록 연속성을 확립하는 것이다.** Entity를 모델링할 때, 속성이나 행위에 집중하기 보다는 가장 본질적인 특징(Entity를 식별하고 탐색하여 일치시키는데 사용하는)만으로 정의한다. 개념에 필수적인 것만 추가하고 그 행위에 필요한 속성만 추가한다.

그 밖의 것들은 행위나 속성을 검토하여 Entity와 연관관계에 있는 다른 객체로 옮기도록 한다. 이들은 다른 Entity가 되거나 Value Object가 될 것이다.

---

![02.png](/static/assets/img/blog/programming/2019-04-28-domain_driven_design_05/02.png)

위의 그림에서 customerID는 Entity의 유일한 식별자이며, 전화번호와 주소(contact phone, contact address)는 이러한 Customer를 찾거나 일치 여부를 판단하는 데 사용된다. 이름(name)은 한 사람의 식별성을 정의하지는 않지만 간혹 식별성을 판단하는 수단의 일부로 사용되기도 한다. 

이에 따라 이름, 연락처 같은 속성을 Customer로 옮겼지만 그 것은 어느 두 Customer 간의 식별성을 파악하기 위해 옮긴 것이다. 만약 Customer에 여러 전화번호가 있고 그 번호가 식별성과 관련이 없다면 Sale Contact에 그대로 있어야 한다.

<br>

### 식별 연산의 설계

각 Entity에는 다른 객체와 구분해줄 식별성을 만들어낼 수 있는 수단이 있어야 한다. 식별에 사용되는 속성은 시스템의 상태와 관계없이 해당 시스템에서 유일해야 한다.

**식별성에 대한 정의는 모델로부터 나온다. 따라서 식별성을 정의하려면 도메인을 이해해야 한다.**

