---
layout: post
title:  "디자인 패턴 01 - 추상 팩토리 (Abstraction Factory)"
date:   2019-07-28
desc:  "디자인 패턴 01 - 추상 팩토리 (Abstraction Factory)"
keywords: "디자인 패턴, Design Patterns, 생성 패턴, 추상 팩토리, Abstraction Factory"
categories: [Programming]
tags: [Design Patterns]
icon: icon-html
---

추상 팩토리 패턴은 객체 생성을 위한 패턴으로, 서로 관련성이 있거나 독립적인 여러 **객체들의 집합을 생성**하기 위한 인터페이스를 제공한다.

![00.png](/static/assets/img/blog/programming/2019-07-28-design_patterns_01/00.png)

위의 그림과 같이 클라이언트는 추상 팩토리 클래스(**AbstractFactory**)로 인스턴스를 요청한다.

인스턴스 요청시, 추상 팩토리 클래스를 구현한 구체 팩토리 클래스(**ConcreteFactory1, ConcreteFactory2**)가 인스턴스를 생성하며, 반환되는 타입은 클라이언트가 필요로 하는 객체의 기능을 정의한 인터페이스 or 추상 클래스 타입이다. (**AbstractProductA, AbstractProductB**)

> 일반적으로 구체 팩토리 클래스의 인스턴스가 런타임에 한 개 만들어진다. 이 하나의 구체 팩토리는 어떤 특정 구현을 담당하는 객체 집합을 생성한다. 다른 구현의 객체 집합을 사용하려면 다른 구체 팩토리를 사용한다.

**추상 팩토리 클래스는 클라이언트가 필요로 하는 객체를 생성하는 연산을 정의**하며, 이 연산을 구현하는 책임은 구체 팩토리 클래스가 맡는다. **추상 팩토리 클래스는 실제 객체를 생성하는 책임을 구체 팩토리 클래스로 위임하는 것이다.** 

또한 반환되는 타입도 실제 구현 클래스가 아닌 인터페이스 / 추상 클래스 타입이다. 이를 통해 클라이언트는 어느 구현 클래스가 자신이 필요로 하는 객체를 생성하는지, 또는 얻은 인스턴스의 구체적인 클래스가 무엇인지 알 필요가 없다.

추상 팩토리 패턴은 다음의 경우에 사용할 수 있다.

1. 객체가 생성되거나 구성, 표현되는 방식과는 무관하게 시스템을 독립적으로 만들고자 할 때
2. 여러 객체 집합 중 하나를 선택하여 사용해야 하고, 다른 객체 집합으로 대체할 수 있을 때
3. 관련된 객체들이 함께 사용되도록 설계되었고, 이 부분에 대한 제약이 지켜지도록 하고 싶을 때
   - 어느 특정 집합의 객체들이 함께 사용해야 되도록 설계되었다면, 특정 팩토리 클래스를 사용함으로써 이를 쉽게 지킬 수 있다.
4. 라이브러리 제공시, 그들의 구현이 아닌 인터페이스를 노출시키고 싶을 때

객체를 생성하는 과정과 책임을 캡슐화함으로써, 구체적인 구현 클래스가 클라이언트로부터 분리된다. 사용할 팩토리 클래스를 변경함으로써, 사용자가 쓸 객체들을 쉽게 변경할 수 있다.

> 집합에 새로운 클래스를 정의하거나, 클라이언트가 사용하는 객체의 인터페이스나 추상클래스(**AbstractProductA, AbstractProductB**)가 변경되면, 실제 인스턴스를 생성하는 연산을 정의하는 추상 팩토리 및 이를 구현하는 모든 구체 클래스의 변경이 필요하다.

> 추상 팩토리 및 구체 팩토리 클래스는 팩토리 메서드를 이용해서 구현되는데, 원형(prototype) 패턴을 사용할 때도 있다. 보통 구체 팩토리 인스턴스는 하나만 있으면 되므로, 단일체(singleton) 패턴을 통해 생성된다.

[Abstract Factory Example
](https://github.com/dhsim86/design_pattern_study/commit/b6753b07a023922ec83cfaec5db565abe60568f9)