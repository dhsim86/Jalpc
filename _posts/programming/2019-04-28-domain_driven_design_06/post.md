---
layout: post
title:  "도메인 주도 설계 06 - 도메인 객체의 생명주기"
date:   2019-04-28
desc:  "도메인 주도 설계 06 - 도메인 객체의 생명주기"
keywords: "DDD, Domain, Domain Driven Design, Aggregate, Repository, Factory"
categories: [Programming]
tags: [DDD, Domain, Domain Driven Design]
icon: icon-html
---

모든 객체에는 생명주기가 있다. 한 객체는 생성되어 다양한 상태를 거친 후 결국 저장되거나 삭제되면서 소멸한다. 다른 객체와 복잡한 상호의존성을 맺으며, 여러 가지 상태의 변화를 겪기도 하는데 이 때 갖가지 불변식이 적용된다. 이러한 객체들을 관리하는데 실패한다면 Model-Driven Design을 시도하는 것이 쉽게 좌절될 수 있다.

![00.png](/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/00.png)

도메인 객체의 관리와 관련되 문제는 아래의 두 가지 범주로 나뉜다.

* 생명주기 동안의 무결성 유지하기
* 생명주기 관리의 복잡성으로 모델이 난해해지는 것을 방지하기

이러한 문제를 해결하는데 도메인 주도 설계에서는 세 가지 패턴을 통해 해결한다.

* Aggregate: **소유권과 경계를 명확히 정의하여 모델을 엄격하게 만들어** 객체 간의 연관관계가 혼란스럽게 얽히는 것을 방지하고, 도메인 객체의 **무결성**을 유지한다.
* Factory: 복잡한 객체와 Aggregate를 생성 및 재구성함으로써 그것들의 **내부 구조를 캡슐화**한다.
* Repository: **영속성과 관련된 인프라스트럭처를 캡슐화하면서 영속 객체를 찾아 조회하는 수단**을 제공한다.

Repository와 Factory가 도메인에서 나오는 것은 아니지만, 그것들은 도메인 설계에서 중요한 역할을 담당한다. Aggregate를 모델링하고 Repository와 Factory를 통해 모델 객체의 생명주기 동안 그것들 체계적이고 의미 있는 단위로 조작할 수 있다.

**Aggregate는 생명주기의 전 단계에서 불변식이 유지해야할 범위를 표시하는 것이며, Repository와 Factory는 Aggregate를 대상으로 연산을 수행하며 특정 생명주기로 이동하는 과정에 따른 복잡성을 캡슐화한다.**

<br>

## Aggregate (집합체)

연관관계를 최소주의 관점에서 설계하면 탐색이 단순해지고 증가하는 관계를 제한하는데 어느정도 도움이 되긴 하지만, 대부분의 업무 도메인은 상호 연관의 정도가 높으므로 객체 참조를 통해 얽히고 설킨 객체 관계망을 추적해야 한다. 그런데 이런 과도한 관계망은 소프트웨어 설계에서는 문제가 된다.

**일반적인 객체 모델의 관계망은 잠재적인 변경의 효과가 미칠 범위를 명확히 한정해주지 않는다.** 특히 동일한 객체에 여러 클라이언트가 동시에 접근하는 시스템에서는 문제가 심각해질 수 있다. **변경의 범위를 알맞게 제한하지 않는다면 심각한 결과가 초래될 것이다.**

모델 내에서 복잡한 연관관계를 맺는 객체를 대상으로 변경의 일관성을 보장하기란 쉽지 않다. **개별 객체뿐만 아니라 그 객체가 참조하는, 서로 밀접한 관계에 있는 객체 집합에도 불변식이 적용되어야 하기 때문이다.**

이러한 문제의 균형잡힌 해법을 찾기 위해서는 도메인을 심층적으로 이해해야 하며, 특히 특정 클래스의 인스턴스 사이의 변화 빈도와 같은 사항까지도 이해하고 있어야 한다. **경합이 높은 지점을 느슨하게 연결하고, 엄격한 불변식을 더욱 엄격하게 지켜지케 하는 모델을 찾을 필요가 있다.**

문제의 근원은 **모델에 경계가 정의되어 있지 않다는 점이다.** 모델을 근간으로 하는 해법을 이용하면 모델을 좀 더 이해하기 쉬워지고 설계한 바가 더 쉽게 전달될 것이다.

다음과 같은 엄격한 체계는 그와 같은 개념에서 정수를 뽑아낸 것이다.

**모델 내의 참조에 대한 캡슐화를 추상화할 필요가 있다.** **Aggregate는 데이터 변경의 "단위"로 다루는 연관 객체의 묶음을 말하는데, 각 Aggregate에는 루트(root)와 경계(boundary)가 있다.** 

* 경계: Aggregate에 무엇이 포함되고 포함되지 않는지를 정의한다.
* 루트: Aggregate 내에 단 하나만 존재하며 특정 Entity를 가리킨다.

경계 안의 객체들은 서로 참조할 수 있지만, **경계 바깥의 객체는 해당 Aggregate의 구성요소 가운데 루트만 참조할 수 있다.**

> 루트 이외의 Aggregate 내부의 Entity는 지역 식별성을 가지며, Aggregate 내에서만 구분된다. Aggregate 경계 밖에서는 루트 Entity 말고는 내부를 직접 들여다 볼 수 없도록 하기 때문이다.

![01.png](/static/assets/img/blog/programming/2019-04-28-domain_driven_design_06/01.png)

위의 그림과 같이 Car는 외부에서 식별할 수 있는 루트 Entity이며, Aggregate 내부의 Wheel, Tire는 외부에서 바로 접근할 수 없다.

**불변식은 데이터가 변경될 때마다 유지되어야 하는 일관성 규칙을 뜻하며, Aggregate를 구성하는 각 구성요소 간의 관계도 포함한다.** 

이런 특징을 가지는 Aggregate에 대한 트랜잭션에 적용되는 규칙은 다음과 같다.

1. 루트 Entity는 전역 식별성을 가지며, 불변식을 검사할 책임이 있다.
2. Aggregate 경계 안의 Entity들은 지역 식별성을 지니며, Aggregate 내부에서만 유일하다.
3. Aggregate 경계 밖에서는 루트 Entity를 제외하고는 내부의 구성요소에 대해 직접 참조할 수 없다.
    * 루트 Entity가 내부 Entity에 대한 참조를 바깥에 전달해 줄 수는 있지만 그러한 객체는 바깥에서 일시적으로만 사용해야 되고 계속 보유하면 안된다.
    * 방어적 복사를 통해 다른 객체에 전달하도록 하며 외부에 의해 불변식이 깨지지 않도록 한다.
4. 데이터베이스에 질의를 하면 Aggregate의 루트만 직접적으로 획득하도록 구현한다.
    * Aggregate 내부의 다른 객체들은 모두 Aggregate의 루트를 통해서 탐색해서 발견해야 한다.
5. Aggregate 안의 객체는 다른 Aggregate의 루트만 참조 가능하다.
6. 삭제 연산은 Aggregate 경계 안의 모든 요소를 한 번에 제거해야 불변식을 지킬 수 있다.
7. Aggregate 경계 안의 어떤 객체를 변경하더라도 전체 Aggregate의 불변식은 지켜져야 한다.

**객체 간의 복잡한 연관관계로 인해 발생하는 문제점을 해소하고, 지켜져야 하는 불변식의 경계를 명확히 하기 위해서는** Entity와 Value Object를 한 Aggregate로 모으고 각각에 대해 경계를 정의하도록 한다.

