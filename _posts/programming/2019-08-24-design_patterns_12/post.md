---
layout: post
title:  "디자인 패턴 12 - 프록시 (Proxy)"
date:   2019-08-24
desc:  ""디자인 패턴 12 - 프록시 (Proxy)"
keywords: "디자인 패턴, Design Patterns, 구조 패턴, 프록시, Proxy"
categories: [Programming]
tags: [Design Patterns]
icon: icon-html
---

프록시(Proxy) 패턴은 **다른 객체에 대한 접근을 제어하기 위해** 대리자(Surrogate)나 자리채움자(PlaceHolder) 역할을 하는 객체를 두는 패턴이다.

어떤 객체에 대해 접근을 제어하는 한 가지 이유로는, 실제 그 객체를 사용할 수 있을 때까지 객체 생성과 초기화에 들어가는 비용 및 시간을 들이지 않겠다는 것이다. 서브시스템을 사용하기 위한 초기화 과정에서 특정 객체 생성에 드는 시간과 비용이 많이 들지만, 그 객체를 실제 사용하는 시점은 더 이후라면, 그 객체에 대한 프록시 객체를 둠으로써, 초기화 시간을 단축시킬 수 있다.

**프록시 객체는 실제 객체의 연산에 대한 요청이 오면, 그 때 실제 객체를 생성하여 그 요청을 전달하는 방식으로 동작한다.** 이외에도 프록시 객체는 위의 예 말고도, 원래 **객체에 대한 접근을 제어**하거나 **영속성 저장소로부터 얻을 수 있는 객체에 대해서는 메모리에 캐싱, 또는 동기화 목적으로 락을 거는식**으로 다양한 용도로 사용될 수 있다.

> 객체 복사시 드는 비용을 프록시 패턴을 통해 최적화할 수도 있다. Copy-On-Write와 비슷하게 덩치가 크고 복잡한 객체를 복사시 일단 프록시를 사용해서 실제 복사 절차를 미루었다가, 원본이나 사본이 변경되면 그 때 복사를 수행하는 것이다. 이런 기법은 중량급 객체에 대한 복사 비용을 현격히 줄일 수 있다.

![00.png](/static/assets/img/blog/programming/2019-08-24-design_patterns_12/00.png)

프록시 객체는 실제로 참조할 대상에 대한 참조자를 관리하며, **실제 객체와 동일한 인터페이스를 제공함으로써 실제 객체를 대체할 수 있어야 한다.** 그리고 **사용자 요청에 대해 객체 접근을 제어하거나 객체와 관련된 여러 연산을 수행할 수 있다. 또 실제 객체 생성 및 삭제를 책임진다.**

> 프록시는 실제 객체를 생성하는 책임을 가지고 있으므로 실제 객체를 생성하는 시점이 되면, 어떤 구체적인 클래스의 인스턴스를 생성해야 되는지 알아야 한다.

> 장식자(Decorator) 패턴과 프록시 패턴은 구현 방법이 유사하지만 장식자 패턴이 하나 이상의 기능을 추가하기 위한 목적이었다면, 프록시는 객체에 대한 접근을 제어하려는 목적이라는 점에서 차이가 있다.

