---
layout: post
title:  "Effective Java 04 - 클래스와 인터페이스"
date:   2019-01-14
desc:  "Effective Java 04 - 클래스와 인터페이스"
keywords: "java"
categories: [Java]
tags: [java]
icon: icon-html
---

# 클래스와 인터페이스

<br>
## 15. 클래스와 멤버의 접근 권한을 최소화하라.

**잘 설계된 컴포넌트와 그렇지 않은 것의 차이는 클래스의 내부 데이터와 내부 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐다.**

잘 설계된 컴포넌트는 내부 구현을 완벽히 숨겨, **구현과 API를 깔끔히 분리한다.** 오직 **API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다.** 이를 통해, 시스템을 구성하는 컴포넌트들을 서로 독립시켜 개발, 테스트, 적용 등을 개별적으로 할 수 있게 해준다.

> 정보 은닉, 캡슐화는 소프트웨어 설계의 근간이 되는 원리이다.

자바는 정보 은닉을 위한 다양한 장치를 제공해주고 있다.
그 중 접근 제어 메커니즘은 클래스, 인터페이스, 멤버의 접근성을 명시한다. 각 요소의 접근성은 그 요소가 선언된 위치와 접근 제한자 (private, protected, public)으로 정해진다.

**기본 원칙은 모든 클래스와 멤버의 접근성을 가능한 한 좁혀야 한다는 것이다.**
달리 말해, 소프트웨어가 정상적으로 동작하는 한 가장 낮은 접근 수준을 부여해야 한다는 뜻이다.

톱 레벨 클래스와 인터페이스에 부여할 수 있는 접근 수준은 package-private와 public 이다. 
**public으로 선언하면 공개 API가 되며, package-private로 선언하면 해당 패키지 안에서만 이용할 수 있다.**
따라서 패키지 외부에서 쓸 이유가 없다면 package-private로 선언하는 것이 좋다. 공개된 API가 아닌 내부 구현이 되므로 언제든지 수정이 가능하다. 

만약 한 클래스에서만 사용하는 클래스이거나 인터페이스는 이를 사용하는 클래스 안에 **private static 클래스**로 중첩시키는 것이 낫다.

클래스를 설계할 때는 공개 API를 세심히 설계 후 그 외의 모든 멤버는 private로 선언한다. 그 후에 같은 패키지내의 다른 클래스가 접근할 필요가 생긴다면 그 때 package-private로 만들어주면 된다.

Public 클래스에서의 protected 멤버는 공개 API이다. 따라서 protected 멤버 또한 가능한 적을수록 좋다.

멤버 접근성을 좁히지 못하게 하는 제약 중 하나는 상위 클래스의 메서드를 재정의할 때이다.
**메서드를 재정의할 때는 그 메서드의 접근 수준을 상위 클래스에서보다 좁게 설정할 수 없다.** 이 제약은 상위 클래스의 인스턴스는 하위 클래스의 인스턴스로 대체해 사용할 수 있어야 한다는 리스코프 치환 원칙을 지키기 위해 필요하다.

테스트를 위해 클래스나 인터페이스, 멤버를 public이나 protected로 선언하여 공개 API로 만들면 안된다. 그럴 필요없이 테스트 클래스를 같은 패키지안에 둠으로써, package-private 요소에 접근할 수 있기 때문이다.

**public 클래스의 인스턴스 필드는 되도록 public이 아니어야 한다.**
만약 필드가 참조 필드이거나, final이 아니라면 그 필드에 담을 수 있는 값을 제한할 힘을 잃게 된다. 즉, 그 필드와 관련된 모든 불변식을 보장할 수 없다는 뜻이다.
정적 필드도 마찬가지긴 하지만 클래스가 표현하는 추상 개념을 완성하기 위한 상수라면 public static final 필드로 공개해도 된다. 단, 기본 타입이거나 불변 객체여야 한다. 가변 객체라면 내부 필드를 수정할 수 있다.

> 접근 제한자가 public인 가변 필드는 일반적으로 스레드 안전하지 않다.

자바 9에서는 모듈 시스템이 추가되어 두 가지 암묵적 접근 수준이 추가되었다.
모듈은 패키지의 묶음으로, 공개(export)할 것이라고 명시하지 패지키라면 protected나 public이더라도 모듈 외부에서 접근할 수 없다.

> 단, 모듈에 적용되는 새로운 두 접근 수준은 상당히 주의해서 사용해야 한다. 모듈 jar 파일을 자신의 모듈 경로가 아닌 애플리케이션의 클래스패스에 두면 그 모듈안의 모든 패키지는 모듈이 없는 것처럼 행동한다.

<br>
## 16. public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라.

public 클래스에서는 패키지 바깥에서 필드를 바로 접근할 수 없도록 제한해야 한다.
불변 필드라하더라도 덜 위험하긴 하지만 안심할 수는 없다. 때로는 package-private 클래스나 private 중첩 클래스에서는 종종 필드를 노출하는 편이 나을 때도 있다.

<br>
## 17. 변경 가능성을 최소화하라.

불변 클래스란 **그 인스턴스의 내부 값을 수정할 수 없는 클래스**이다.
불변 클래스는 설계 및 구현하고 사용하기 쉬우며, 오류가 생길 여지도 적고 안전하다.

클래스를 불변으로 만들기 위해 다음 규칙을 따른다.

* 객체의 상태를 변경하는 메서드(예를 들면 setter)를 제공하지 않는다.
* 클래스를 확장할 수 없도록 한다.
  * 대표적으로 final로 선언하거나 private 생성자를 만든 후 정적 팩토리 메서드로만 인스턴스화하는 것이다.
* 모든 필드를 final로 선언한다.
  * 설계자의 의도를 명확히하고, 스레드 간의 동기화없어도 문제없이 사용할 수 있다.
* 모든 필드를 private로 선언한다.
  * 필드가 참조하는 가변 객체를 클라이언트에서 직접 접근해 수정하는 일이 없도록 한다.
* 자신외에는 내부의 가변 컴포넌트에 접근할 수 없도록 한다.
  * 가변 객체를 하나라도 참조한다면 클라이언트에서 그 객체 참조를 얻을 수 없도록 해야 한다.

**불변 객체는 근본적으로 스레드 안전하여 따로 동기화할 필요가 없다.**
또한 같은 불변 객체가 수시로 필요할 경우, 인스턴스를 중복해서 생성하지 않고 내부적으로 캐싱하는 정적 팩토리 메서드를 통해 성능 향상을 도모할 수 있다.

> 불변 객체는 자유롭게 공유할 수 있으므로 clone 메서드나 복사 생성자를 제공해봐야 의미가 없다.

불변 클래스에도 단점은 존재한다. **값이 다르다면 반드시 서로 다른 독립된 객체로 존재해야 한다.**

**모든 클래스를 불변 클래스로 만들 수는 없지만, 그런 클래스이더라도 변경 가능한 부분을 최소화하는 것이 좋다.**
따라서 꼭 변경해야 할 필드를 뺀 나머지 모두는 final로 선언하는 것이 좋다.